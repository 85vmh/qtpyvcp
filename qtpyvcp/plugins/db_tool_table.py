"""Tool Table data plugin.

Exposes all the info available in the tool table. Watches the
tool table file for changes and re-loads as needed.

Tool Table YAML configuration:

.. code-block:: yaml

    data_plugins:
      tooltable:
        kwargs:
          # specify the columns that should be read and writen to the
          # tooltable file. To use all columns set to: TPXYZABCUVWDIJQR
          columns: PTDZR
          # specify text to be added before the tool table data
          file_header_template: |
            LinuxCNC Tool Table
            -------------------

            QtPyVCP will preserve comments before the opening semicolon.
"""

import os
import sys
import re
import io

from itertools import takewhile
from datetime import datetime

from  linuxcnc import command

from qtpy.QtCore import QFileSystemWatcher, QTimer, Signal, Slot

import qtpyvcp

from sqlalchemy import delete
from qtpyvcp.lib.db_tool.base import Session, Base, engine
from qtpyvcp.lib.db_tool.tool_table import ToolTable, Tool

from qtpyvcp.utilities.info import Info
from qtpyvcp.utilities.logger import getLogger
from qtpyvcp.actions.machine_actions import issue_mdi
from qtpyvcp.plugins import DataPlugin, DataChannel, getPlugin

import pprint

CMD = command()
LOG = getLogger(__name__)
STATUS = getPlugin('status')
STAT = STATUS.stat
INFO = Info()

IN_DESIGNER = os.getenv('DESIGNER', False)


def merge(a, b):
    """Shallow merge two dictionaries"""
    r = a.copy()
    r.update(b)
    return r


DEFAULT_TOOL = {
    'A': 0.0,
    'B': 0.0,
    'C': 0.0,
    'D': 0.0,
    'I': 0.0,
    'J': 0.0,
    'P': 0,
    'Q': 1,
    'T': -1,
    'U': 0.0,
    'V': 0.0,
    'W': 0.0,
    'X': 0.0,
    'Y': 0.0,
    'Z': 0.0,
    'R': '',
}

NO_TOOL = merge(DEFAULT_TOOL, {'T': 0, 'R': 'No Tool Loaded'})

# FILE_HEADER = """
# LinuxCNC Tool Table
# -------------------
#
# (QtPyVCP will preserve any comments before this separator.)
# ---
# Generated by: QtPyVCP ToolTable plugin ({version})
# Generated on: {datetime:%x %I:%M:%S %p}
#
# """

COLUMN_LABELS = {
    'A': 'A Offset',
    'B': 'B Offset',
    'C': 'C Offset',
    'D': 'Diameter',
    'I': 'Fnt Ang',
    'J': 'Bak Ang',
    'P': 'Pocket',
    'Q': 'Orient',
    'R': 'Remark',
    'T': 'Tool',
    'U': 'U Offset',
    'V': 'V Offset',
    'W': 'W Offset',
    'X': 'X Offset',
    'Y': 'Y Offset',
    'Z': 'Z Offset',
}

# Column formats when writing tool table
INT_COLUMN_WIDTH = 6
FLOAT_COLUMN_WIDTH = 12
FLOAT_DECIMAL_PLACES = 6


def makeLorumIpsumToolTable():
    return {i: merge(DEFAULT_TOOL,
                     {'T': i, 'P': i, 'R': 'Lorum Ipsum ' + str(i)})
            for i in range(10)}


class ToolTable(DataPlugin):

    TOOL_TABLE = {0: NO_TOOL}
    DEFAULT_TOOL = DEFAULT_TOOL
    COLUMN_LABELS = COLUMN_LABELS

    tool_table_changed = Signal(dict)

    def __init__(self, columns='TPXYZABCUVWDIJQR', file_header_template=None,
                 remember_tool_in_spindle=True):
        super(ToolTable, self).__init__()

        Base.metadata.create_all(engine)
        
        self.table = dict()
        # self.fs_watcher = None
        # self.orig_header_lines = []
        # self.file_header_template = file_header_template or ''
        # self.remember_tool_in_spindle = remember_tool_in_spindle
        self.columns = self.validateColumns(columns) or [c for c in 'TPXYZABCUVWDIJQR']
        #
        # self.data_manager = getPlugin('persistent_data_manager')
        #
        # self.setCurrentToolNumber(0)
        #
        # self.tool_table_file = INFO.getToolTableFile()
        # if not os.path.exists(self.tool_table_file):
        #     return
        #
        
        #
        # self.current_tool.setValue(self.TOOL_TABLE[STATUS.tool_in_spindle.getValue()])
        #
        # # update signals
        # STATUS.tool_in_spindle.notify(self.setCurrentToolNumber)
        # STATUS.tool_table.notify(lambda *args: self.loadToolTable())
        #
        # STATUS.all_axes_homed.notify(self.reload_tool)

    def reload_tool(self):
        if self.remember_tool_in_spindle and STATUS.all_axes_homed.value and STATUS.enabled.value:
            tnum = self.data_manager.getData('tool-in-spindle', 0)
            LOG.debug("reload_tool: tool in spindle: %i new tool: %i" % (STAT.tool_in_spindle, tnum))
            if STAT.tool_in_spindle == 0 and tnum != STAT.tool_in_spindle:
                LOG.info("Reloading tool in spindle: %i", tnum)
                cmd = "M61 Q{0} G43".format(tnum)
                # give LinuxCNC time to switch modes
                QTimer.singleShot(200, lambda: issue_mdi(cmd))

    @DataChannel
    def current_tool(self, chan, item=None):
        """Current Tool Info

        Available items:

        * T -- tool number
        * P -- pocket number
        * X -- x offset
        * Y -- y offset
        * Z -- z offset
        * A -- a offset
        * B -- b offset
        * C -- c offset
        * U -- u offset
        * V -- v offset
        * W -- w offset
        * I -- front angle
        * J -- back angle
        * Q -- orientation
        * R -- remark

        Rules channel syntax::

            tooltable:current_tool
            tooltable:current_tool?X
            tooltable:current_tool?x_offset

        :param item: the name of the tool data item to get
        :return: dict, int, float, str
        """
        if item is None:
            return self.TOOL_TABLE[STAT.tool_in_spindle]
        return self.TOOL_TABLE[STAT.tool_in_spindle].get(item[0].upper())

    def initialise(self):
        self.session = Session()
        self.loadToolTable()

    def terminate(self):
        self.session.close()

    @staticmethod
    def validateColumns(columns):
        """Validate display column specification.

        The user can specify columns in multiple ways, method is used to make
        sure that that data is validated and converted to a consistent format.

        Args:
            columns (str | list) : A string or list of the column IDs
                that should be shown in the tooltable.

        Returns:
            None if not valid, else a list of uppercase column IDs.
        """
        if not isinstance(columns, (str, list, tuple)):
            return

        return [col for col in [col.strip().upper() for col in columns]
                if col in 'TPXYZABCUVWDIJQR' and not col == '']

    def newTool(self, tnum=None):
        """Get a dict of default tool values for a new tool."""
        if tnum is None:
            tnum = len(self.TOOL_TABLE)
        new_tool = DEFAULT_TOOL.copy()
        new_tool.update({'T': tnum, 'R': 'New Tool'})
        return new_tool

    def setCurrentToolNumber(self, tool_num):
        self.current_tool.setValue(self.TOOL_TABLE[tool_num])

    def reloadToolTable(self):
        self.loadToolTable()
        
    def loadToolTable(self): 
        print("Loads ToolTable")       
        tool_list = self.session.query(Tool).all()
        
        for tool in tool_list:
                   
            self.table[tool.tool_no] = {'A': tool.a_offset,
                                        'B': tool.b_offset,
                                        'C': tool.b_offset,
                                        'D': tool.diameter,
                                        'I': 0.0,
                                        'J': 0.0,
                                        'P': tool.pocket,
                                        'Q': 1,
                                        'R': tool.remark,
                                        'T': tool.tool_no,
                                        'U': tool.u_offset,
                                        'V': tool.v_offset,
                                        'W': tool.w_offset,
                                        'X': tool.x_offset,
                                        'Y': tool.y_offset,
                                        'Z': tool.z_offset}

        self.tool_table_changed.emit(self.table.copy())

    def getToolTable(self):
        return self.table.copy()

    def saveToolTable(self, tool_table, columns=None):
        """Write tooltable data to db.

        Args:
            tool_table (dict) : Dictionary of dictionaries containing
                the tool data to write to the file.
            columns (str | list) : A list of data columns to write.
                If `None` will use the value of ``self.columns``.
            tool_file (str) : Path to write the tooltable too.
                Defaults to ``self.tool_table_file``.
        """
        
        print("#########################")
        print("##### TOOLS IN DB #######")
        
        for k, v in self.table.items():
            print(k, v)
        print("#########################")
        print("#### TOOLS IN WIDGET ####")
            
        for k, v in tool_table.items():
            print(k, v)
        print("#########################")
            
        return
    
    
        for tool in tool_db:
            if tool.tool_no not in tool_table.keys():
                print(f"TO DELETE tool {tool.tool_no}")
                # tool_data = tool.filter(Tool.tool_no == tool['T']).one()
                # self.session.delete(tool_data)

            elif tool.tool_no not in self.table.keys():
                print(f"TO INSERT tool {too.tool_no}")
                
                # self.session.add(
                #     Tool(remark=tool['R'],
                #          tool_no=tool['T'],
                #          in_use=False,
                #          pocket=tool['P'],
                #          x_offset=tool['X'],
                #          y_offset=tool['Y'],
                #          z_offset=tool['Z'],
                #          a_offset=tool['A'],
                #          b_offset=tool['B'],
                #          c_offset=tool['C'],
                #          u_offset=tool['U'],
                #          v_offset=tool['V'],
                #          w_offset=tool['W'],
                #          diameter=tool['D'],
                #          tool_holder="models/tool.stl",
                #          tool_table_id=0
                #     )
                # )
            
            else:
                print(f"TO UPDATE tool {tool.tool_no}")
                # print( tool_no)
                #
                # pprint.pprint(tool_db)
                #
                # a = tool
                # b = tool_db[tool_no]
                #
                # print(a)
                # print(b)
                
                # value = { k : second_dict[k] for k in set(second_dict) - set(first_dict) }
                #
                # result = dict(a ^ b)
                #
                # print(result)
                # continue
                #
                # s = SequenceMatcher(None,a, b)
                # for opcode in s.get_grouped_opcodes():
                #     print("%6s a[%d:%d] b[%d:%d]" % opcode)
                # continue
                #
                # for k,v in tool.items():
                #     if v != self.table[tool_no][k]:
                #         print(f"TO UPDATE tool {tool_no}")
                #     else:
                #         print(f"No UPDATE {v} {self.table[tool_no][k]}")
                
                # tool_data = self.session.query(Tool).filter(Tool.tool_no == tool['T']).one()
                #
                # tool_data.remark=tool['R'],
                # tool_data.tool_no=tool['T'],
                # tool_data.in_use=False,
                # tool_data.pocket=tool['P'],
                # tool_data.x_offset=tool['X'],
                # tool_data.y_offset=tool['Y'],
                # tool_data.z_offset=tool['Z'],
                # tool_data.a_offset=tool['A'],
                # tool_data.b_offset=tool['B'],
                # tool_data.c_offset=tool['C'],
                # tool_data.u_offset=tool['U'],
                # tool_data.v_offset=tool['V'],
                # tool_data.w_offset=tool['W'],
                # tool_data.diameter=tool['D'],
                # tool_data.tool_holder="models/tool.stl",
                # tool_data.tool_table_id=0

        self.session.commit()
