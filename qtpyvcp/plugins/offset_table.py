"""
Offset Table data plugin.

Exposes all the info available in the Offset table. Watches the
offset table for changes and re-loads as needed.

Offset Table YAML configuration:

.. code-block:: yaml

    data_plugins:
      offsettable:
        kwargs:
          # specify the columns that should be read and writen to the
          # tooltable file. To use all columns set to: ABCUVWXYZ
          columns: XYZAB
"""

import os
from itertools import takewhile
from datetime import datetime

import linuxcnc

from qtpy.QtCore import QFileSystemWatcher, QTimer, Signal

import qtpyvcp
from qtpyvcp.utilities.info import Info
from qtpyvcp.utilities.logger import getLogger
from qtpyvcp.plugins import DataPlugin, DataChannel, getPlugin

CMD = linuxcnc.command()
LOG = getLogger(__name__)
STATUS = getPlugin('status')
STAT = STATUS.stat
INFO = Info()

IN_DESIGNER = os.getenv('DESIGNER', False)


def merge(a, b):
    """Shallow merge two dictionaries"""
    r = a.copy()
    r.update(b)
    return r


DEFAULT_OFFSET = {
    'A': 0.0,
    'B': 0.0,
    'C': 0.0,
    'U': 0.0,
    'V': 0.0,
    'W': 0.0,
    'X': 0.0,
    'Y': 0.0,
    'Z': 0.0,
}

NO_TOOL = merge(DEFAULT_OFFSET, {'T': 0, 'R': 'No Tool Loaded'})

# FILE_HEADER = """
# LinuxCNC Tool Table
# -------------------
#
# (QtPyVCP will preserve any comments before this separator.)
# ---
# Generated by: QtPyVCP ToolTable plugin ({version})
# Generated on: {datetime:%x %I:%M:%S %p}
#
# """

COLUMN_LABELS = {
    'A': 'A',
    'B': 'B',
    'C': 'C',
    'U': 'U',
    'V': 'V',
    'W': 'W',
    'X': 'X',
    'Y': 'Y',
    'Z': 'Z',
}

ROW_LABELS = {
    'P0': 'G53',
    'P1': 'G54',
    'P2': 'G55',
    'P3': 'G56',
    'P4': 'G57',
    'P5': 'G58',
    'P6': 'G59',
    'P7': 'G59.1',
    'P8': 'G59.2',
    'P9': 'G59.3',
}


def makeLorumIpsumOffsetTable():
    return {i: merge(DEFAULT_OFFSET,
                     {'T': i, 'P': i, 'R': 'Lorum Ipsum ' + str(i)})
            for i in range(10)}


class OffsetTable(DataPlugin):
    OFFSET_TABLE = {0: NO_TOOL}
    DEFAULT_OFFSET = DEFAULT_OFFSET
    COLUMN_LABELS = COLUMN_LABELS
    ROW_LABELS = ROW_LABELS

    offset_table_changed = Signal(dict)

    def __init__(self, columns='ABCUVWXYZ', file_header_template=None):
        super(OffsetTable, self).__init__()

        self.status = STATUS

        self.columns = self.validateColumns(columns) or [c for c in 'ABCUVWXYZ']

        self.setCurrentToolNumber(0)

        self.g5x_offset = None

        self.loadOffsetTable()

        self.current_tool.setValue(self.OFFSET_TABLE[STATUS.tool_in_spindle.getValue()])

        # update signals
        # STATUS.tool_in_spindle.notify(self.setCurrentToolNumber)
        self.status.tool_table.notify(lambda *args: self.loadOffsetTable())

    @DataChannel
    def current_tool(self, chan, item=None):
        """Current Tool Info

        Available items:

        * X -- x offset
        * Y -- y offset
        * Z -- z offset
        * A -- a offset
        * B -- b offset
        * C -- c offset
        * U -- u offset
        * V -- v offset
        * W -- w offset

        Rules channel syntax::

            tooltable:current_tool
            tooltable:current_tool?X
            tooltable:current_tool?x_offset

        :param item: the name of the tool data item to get
        :return: dict, int, float, str
        """
        if item is None:
            return self.OFFSET_TABLE[STAT.tool_in_spindle]
        return self.OFFSET_TABLE[STAT.tool_in_spindle].get(item[0].upper())

    def initialise(self):
        pass
        # self.fs_watcher = QFileSystemWatcher()
        # self.fs_watcher.addPath(self.tool_table_file)
        # self.fs_watcher.fileChanged.connect(self.onToolTableFileChanged)

    @staticmethod
    def validateColumns(columns):
        """Validate display column specification.

        The user can specify columns in multiple ways, method is used to make
        sure that that data is validated and converted to a consistent format.

        Args:
            columns (str | list) : A string or list of the column IDs
                that should be shown in the tooltable.

        Returns:
            None if not valid, else a list of uppercase column IDs.
        """
        if not isinstance(columns, (basestring, list, tuple)):
            return

        return [col for col in [col.strip().upper() for col in columns]
                if col in 'TPXYZABCUVWDIJQR' and not col == '']

    def newOffset(self, tnum=None):
        """Get a dict of default tool values for a new tool."""
        if tnum is None:
            tnum = len(self.OFFSET_TABLE)
        new_tool = DEFAULT_OFFSET.copy()
        new_tool.update({'T': tnum, 'P': tnum, 'R': 'New Tool'})
        return new_tool

    def onToolTableFileChanged(self, path):
        LOG.debug('Tool Table file changed: {}'.format(path))
        # ToolEdit deletes the file and then rewrites it, so wait
        # a bit to ensure the new data has been writen out.
        QTimer.singleShot(50, self.reloadToolTable)

    def setCurrentToolNumber(self, tool_num):
        self.current_tool.setValue(self.OFFSET_TABLE[tool_num])

    def reloadToolTable(self):
        # rewatch the file if it stop being watched because it was deleted
        if self.tool_table_file not in self.fs_watcher.files():
            self.fs_watcher.addPath(self.tool_table_file)

        # reload with the new data
        tool_table = self.loadOffsetTable()
        self.offset_table_changed.emit(tool_table)

    def iterTools(self, tool_table=None, columns=None):
        tool_table = tool_table or self.OFFSET_TABLE
        columns = self.validateColumns(columns) or self.columns
        for tool in sorted(tool_table.iterkeys()):
            tool_data = tool_table[tool]
            yield [tool_data[key] for key in columns]

    def loadOffsetTable(self):

        self.g5x_offset = self.status.stat.g5x_offset

        header = "XYZABCUVW"

        table = {0: NO_TOOL, }
        offset = DEFAULT_OFFSET.copy()

        for index, axis_offset in enumerate(self.g5x_offset):
            print(index, axis_offset)
            offset[header[index]] = axis_offset

        table[0] = offset

        # update tooltable
        self.__class__.OFFSET_TABLE = table

        self.current_tool.setValue(self.OFFSET_TABLE[STATUS.tool_in_spindle.getValue()])

        # import json
        # print json.dumps(table, sort_keys=True, indent=4)

        self.offset_table_changed.emit(table)
        return table.copy()

    def getOffsetTable(self):
        return self.OFFSET_TABLE.copy()

    def saveToolTable(self, tool_table, columns=None, tool_file=None):
        """Write tooltable data to file.

        Args:
            tool_table (dict) : Dictionary of dictionaries containing
                the tool data to write to the file.
            columns (str | list) : A list of data columns to write.
                If `None` will use the value of ``self.columns``.
            tool_file (str) : Path to write the tooltable too.
                Defaults to ``self.tool_table_file``.
        """

        columns = self.validateColumns(columns) or self.columns

        if tool_file is None:
            tool_file = self.tool_table_file

        lines = []
        header_lines = []

        # restore file header
        if self.file_header_template:
            try:
                header_lines = self.file_header_template.format(
                    version=qtpyvcp.__version__,
                    datetime=datetime.now()).lstrip().splitlines()
                header_lines.append('')  # extra new line before table header
            except:
                pass

        if self.orig_header_lines:
            try:
                self.orig_header_lines.extend(header_lines[header_lines.index('---'):])
                header_lines = self.orig_header_lines
            except ValueError:
                header_lines = self.orig_header_lines

        lines.extend(header_lines)

        # create the table header
        items = []
        for col in columns:
            if col == 'R':
                continue
            w = (6 if col in 'TPQ' else 8) - 1 if col == self.columns[0] else 0
            items.append('{:<{w}}'.format(COLUMN_LABELS[col], w=w))

        items.append('Remark')
        lines.append(';' + ' '.join(items))

        # add the tools
        for tool_num in sorted(tool_table.iterkeys())[1:]:
            items = []
            tool_data = tool_table[tool_num]
            for col in columns:
                if col == 'R':
                    continue
                items.append('{col}{val:<{w}}'
                             .format(col=col,
                                     val=tool_data[col],
                                     w=6 if col in 'TPQ' else 8))

            comment = tool_data.get('R', '')
            if comment is not '':
                items.append('; ' + comment)

            lines.append(''.join(items))

        # for line in lines:
        #     print line

        # write to file
        with open(tool_file, 'w') as fh:
            fh.write('\n'.join(lines))
            fh.write('\n')  # new line at end of file
            fh.flush()
            os.fsync(fh.fileno())

        CMD.load_tool_table()
